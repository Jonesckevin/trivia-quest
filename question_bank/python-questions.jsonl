{"id": "0dd7e34fa4818d9ef6d3256b95201fb7", "QuestionId": 1, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Python uses simple assignment with the = operator. Unlike other languages, Python doesn't require type declarations or keywords like 'var', 'let', or 'int'.", "Question": "What is the correct way to create a variable named 'x' with value 5?", "Answers": ["x = 5"], "IncorrectAnswers": ["var x = 5", "int x = 5", "x := 5", "let x = 5", "define x = 5", "x == 5"], "RegEx": "", "RegExDescription": ""}
{"id": "1c5a997f1109c44189e48d28094a31b1", "QuestionId": 2, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The hash symbol (#) starts a single-line comment in Python. Everything after # on that line is ignored by the interpreter.", "Question": "Which symbol is used for single-line comments in Python?", "Answers": ["#"], "IncorrectAnswers": ["//", "/*", "--", "'''", "<!--", "%%"], "RegEx": "", "RegExDescription": ""}
{"id": "17016c475d5d21316bf011e7c7da49d4", "QuestionId": 3, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Numbers with decimal points are automatically typed as 'float' in Python. The type() function returns the class/type of any object.", "Question": "What is the output of print(type(3.14))?", "Answers": ["<class 'float'>"], "IncorrectAnswers": ["<class 'int'>", "<class 'double'>", "<class 'decimal'>", "<class 'number'>", "<class 'real'>", "<class 'numeric'>"], "RegEx": "", "RegExDescription": ""}
{"id": "c72702b4dcb9843a304141364a0c3d40", "QuestionId": 4, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The input() function reads a line from user input and returns it as a string. In Python 2, raw_input() was used instead.", "Question": "How do you get user input in Python 3?", "Answers": ["input()"], "IncorrectAnswers": ["raw_input()", "read()", "scan()", "get_input()", "readline()", "prompt()"], "RegEx": "", "RegExDescription": ""}
{"id": "a30ffce651ce150ab5ef68098b8ef219", "QuestionId": 5, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The 'def' keyword (short for 'define') is used to declare functions in Python. Functions are defined with def, followed by the function name, parentheses for parameters, and a colon.", "Question": "What keyword is used to define a function in Python?", "Answers": ["def"], "IncorrectAnswers": ["function", "func", "define", "fn", "method", "sub"], "RegEx": "", "RegExDescription": ""}
{"id": "9da823bd01d1a6a90ddf5db0d6fe6020", "QuestionId": 6, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Python uses ** for exponentiation (e.g., 2**3 = 8). The ^ operator is used for bitwise XOR, not exponentiation as in some other languages.", "Question": "Which operator is used for exponentiation in Python?", "Answers": ["**"], "IncorrectAnswers": ["^", "^^", "pow", "exp", "//", "%%"], "RegEx": "", "RegExDescription": ""}
{"id": "712237943be1e6a80a94cf45161be7eb", "QuestionId": 7, "Difficulty": "L1", "Category": "Basics", "Type": "regex", "Description": "The // operator performs floor division, returning the largest integer less than or equal to the result. 10 // 3 = 3 (not 3.33).", "Question": "What is the output of print(10 // 3)?", "Answers": ["3"], "IncorrectAnswers": ["3.33", "3.0", "4", "10/3", "1", "0"], "RegEx": "^(3|three)$", "RegExDescription": "Accepts 3 in numeric or word form"}
{"id": "cd02b9fbe689de80c9e2802505090470", "QuestionId": 8, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Triple quotes (''' or \"\"\") allow strings to span multiple lines and preserve line breaks. They're also commonly used for docstrings.", "Question": "How do you create a multi-line string in Python?", "Answers": ["Using triple quotes (''' or \"\"\")"], "IncorrectAnswers": ["Using backslash at end of each line only", "Using @\" \"", "Using << >>", "Using ( )", "Using [ ]", "Using { }"], "RegEx": "", "RegExDescription": ""}
{"id": "f3cd21065bdddad564888e6f7ab998f8", "QuestionId": 9, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Empty sequences (lists, strings, tuples) are 'falsy' in Python and evaluate to False in boolean context. Non-empty sequences are 'truthy'.", "Question": "What is the boolean value of an empty list []?", "Answers": ["False"], "IncorrectAnswers": ["True", "None", "0", "null", "undefined", "empty"], "RegEx": "", "RegExDescription": ""}
{"id": "c83ca56b93fed362766cef11e89db155", "QuestionId": 10, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The 'in' keyword checks membership in sequences (lists, strings, tuples) and containers (dicts, sets). It returns True if the value is found.", "Question": "Which keyword is used to check if a value exists in a sequence?", "Answers": ["in"], "IncorrectAnswers": ["contains", "has", "exists", "includes", "find", "search"], "RegEx": "", "RegExDescription": ""}
{"id": "81620fce28dfceafb6d015e9f730658d", "QuestionId": 11, "Difficulty": "L1", "Category": "Basics", "Type": "regex", "Description": "The len() function returns the number of items in a sequence. For strings, it counts characters. 'Python' has 6 characters: P-y-t-h-o-n.", "Question": "What does the len() function return for the string 'Python'?", "Answers": ["6"], "IncorrectAnswers": ["5", "7", "4", "python", "P", "Error"], "RegEx": "^(6|six)$", "RegExDescription": "Accepts 6 in numeric or word form"}
{"id": "5d531432ba53dbe7de73ff225708df55", "QuestionId": 12, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The int() function converts strings or floats to integers. It will raise a ValueError if the string doesn't represent a valid integer.", "Question": "How do you convert the string '42' to an integer?", "Answers": ["int('42')"], "IncorrectAnswers": ["str(42)", "integer('42')", "toInt('42')", "parse('42')", "Number('42')", "cast('42')"], "RegEx": "", "RegExDescription": ""}
{"id": "74b64e43077747269c9392110c7b77d4", "QuestionId": 13, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Python source files use the .py extension. Other extensions include .pyc (compiled bytecode), .pyw (Windows GUI), and .pyi (type stub files).", "Question": "What is the correct file extension for Python files?", "Answers": [".py"], "IncorrectAnswers": [".python", ".pt", ".pyt", ".p", ".pyth", ".pn"], "RegEx": "", "RegExDescription": ""}
{"id": "df901e1a232da1a680f5c926c020cc7e", "QuestionId": 14, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The + operator concatenates strings in Python. 'Hello' + ' ' + 'World' joins the three strings together to form 'Hello World'.", "Question": "What is the output of print('Hello' + ' ' + 'World')?", "Answers": ["Hello World"], "IncorrectAnswers": ["HelloWorld", "Hello+World", "Hello World", "Error", "None", "hello world"], "RegEx": "", "RegExDescription": ""}
{"id": "b5c1f102df7e8d995e9a65cfb3b14583", "QuestionId": 15, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The 'break' statement immediately exits the innermost enclosing for or while loop. It's commonly used when a search condition is met.", "Question": "Which statement is used to exit a loop prematurely?", "Answers": ["break"], "IncorrectAnswers": ["exit", "stop", "end", "return", "quit", "leave"], "RegEx": "", "RegExDescription": ""}
{"id": "f5f0fa580f939544dc19d542ceb2cc9c", "QuestionId": 16, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The 'continue' statement skips the rest of the current iteration and jumps to the next iteration of the loop. Unlike 'break', it doesn't exit the loop.", "Question": "What does the 'continue' statement do in a loop?", "Answers": ["Skips the current iteration and continues with the next"], "IncorrectAnswers": ["Exits the loop", "Restarts the loop", "Pauses the loop", "Ends the program", "Returns a value", "Creates infinite loop"], "RegEx": "", "RegExDescription": ""}
{"id": "7a2d1f65e57bee3595ad163c1d2c5172", "QuestionId": 17, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "Python compares values, not types, when using ==. The integer 2 and float 2.0 have the same numeric value, so they are considered equal.", "Question": "What is the output of print(2 == 2.0)?", "Answers": ["True"], "IncorrectAnswers": ["False", "Error", "None", "2", "2.0", "TypeError"], "RegEx": "", "RegExDescription": ""}
{"id": "9aa00af9a568ebc3ab16a6be0e483e47", "QuestionId": 18, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "The --version flag (or -V) displays the Python interpreter version. This is useful for verifying which Python version is installed or active.", "Question": "How do you check the Python version from command line?", "Answers": ["python --version"], "IncorrectAnswers": ["python -v", "python version", "python /version", "python -ver", "python check", "python info"], "RegEx": "", "RegExDescription": ""}
{"id": "7523345debc7fa54c5c530d94beeb884", "QuestionId": 19, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "None is Python's null value, representing the absence of a value. It's the default return value of functions that don't explicitly return anything.", "Question": "What is None in Python?", "Answers": ["A special constant representing absence of value"], "IncorrectAnswers": ["Zero", "Empty string", "False", "Undefined variable", "Error type", "Null pointer"], "RegEx": "", "RegExDescription": ""}
{"id": "096c68bc24f92ce0d55c814bc2049fec", "QuestionId": 20, "Difficulty": "L1", "Category": "Basics", "Type": "multiple_choice", "Description": "For loops iterate over sequences (lists, ranges, strings) with a known number of elements. While loops are better when the number of iterations depends on a condition.", "Question": "Which loop is used when the number of iterations is known?", "Answers": ["for loop"], "IncorrectAnswers": ["while loop only", "do-while loop", "repeat loop", "foreach loop", "until loop", "loop loop"], "RegEx": "", "RegExDescription": ""}
{"id": "cae78af8840b8afb22c0d9545ad02266", "QuestionId": 21, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Lists can be created using square brackets [] or the list() constructor. Both [] and list() create empty lists. list() is also used to convert other iterables (like tuples or strings) to lists.", "Question": "How do you create an empty list in Python?", "Answers": ["[] or list()"], "IncorrectAnswers": ["() or tuple()", "{} or dict()", "array()", "new List()", "List.new()", "<>"], "RegEx": "", "RegExDescription": ""}
{"id": "3a4743a0a3cb9f463de72cf24d1e3dfc", "QuestionId": 22, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Lists are mutable (can be modified after creation), while tuples are immutable (cannot be changed). Tuples use less memory and are hashable, making them usable as dictionary keys.", "Question": "What is the difference between a list and a tuple?", "Answers": ["Lists are mutable, tuples are immutable"], "IncorrectAnswers": ["Lists are ordered, tuples are unordered", "Tuples can have duplicate values, lists cannot", "Lists use parentheses, tuples use square brackets", "Tuples are mutable, lists are immutable", "Lists can only store one data type", "No difference"], "RegEx": "", "RegExDescription": ""}
{"id": "c2163cd6065d36427181dad234b91d04", "QuestionId": 23, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Negative indexing allows access from the end of a sequence. Index -1 is the last element, -2 is second-to-last, etc. This avoids needing to calculate len(list)-1 to get the last item.", "Question": "How do you access the last element of a list?", "Answers": ["list[-1]"], "IncorrectAnswers": ["list[last]", "list.last()", "list[len(list)]", "list.end()", "list[-0]", "list.tail()"], "RegEx": "", "RegExDescription": ""}
{"id": "371aaef7d5d74296e7aafce6b07865c4", "QuestionId": 24, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "append() adds a single element to the end of a list, modifying it in place. It returns None, not the modified list. For adding multiple elements, use extend() instead.", "Question": "Which method adds an element to the end of a list?", "Answers": ["append()"], "IncorrectAnswers": ["add()", "push()", "insert()", "extend()", "put()", "attach()"], "RegEx": "", "RegExDescription": ""}
{"id": "3eb05c0e44b81d6878488063e1aa9a7e", "QuestionId": 25, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Dictionaries use curly braces with key:value pairs. Keys must be immutable (strings, numbers, tuples) and unique. Values can be any type. Dictionaries are ordered as of Python 3.7+.", "Question": "How do you create a dictionary with key 'name' and value 'John'?", "Answers": ["{'name': 'John'}"], "IncorrectAnswers": ["['name': 'John']", "('name': 'John')", "dict['name'] = 'John'", "{name: John}", "<name: 'John'>", "Dictionary('name', 'John')"], "RegEx": "", "RegExDescription": ""}
{"id": "a36ab4c4aadbf6a8f3d1eaf72f6ba4c8", "QuestionId": 26, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "pop() removes and returns the last element by default. You can pass an index to pop a specific element: pop(0) removes the first. remove() deletes by value, not index, and returns None.", "Question": "What method removes and returns the last element of a list?", "Answers": ["pop()"], "IncorrectAnswers": ["remove()", "delete()", "drop()", "take()", "pull()", "extract()"], "RegEx": "", "RegExDescription": ""}
{"id": "ecb04e51bae3f3aecc70b2600fb9a593", "QuestionId": 27, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "dict.keys() returns a view object containing all keys. Similarly, dict.values() returns values and dict.items() returns key-value tuples. These views reflect changes to the dictionary.", "Question": "How do you get all keys from a dictionary?", "Answers": ["dict.keys()"], "IncorrectAnswers": ["dict.getKeys()", "keys(dict)", "dict.allKeys()", "dict.keySet()", "dict.indexes()", "dict.names()"], "RegEx": "", "RegExDescription": ""}
{"id": "e96526a2f2784f460530069e66af3c5a", "QuestionId": 28, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Sets are unordered collections that automatically eliminate duplicates. They support mathematical set operations like union (|), intersection (&), and difference (-). Sets are mutable but can only contain hashable (immutable) elements.", "Question": "What is a set in Python?", "Answers": ["An unordered collection of unique elements"], "IncorrectAnswers": ["An ordered list of elements", "A key-value pair collection", "An immutable sequence", "A sorted array", "A linked list", "A binary tree"], "RegEx": "", "RegExDescription": ""}
{"id": "98323774f9c4c577638d07a62f4b4e35", "QuestionId": 29, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Sets are created with curly braces containing elements, or set() for empty sets. Note: {} creates an empty dict, not a set! Use set() for empty sets. set([1,2,3]) converts a list to a set.", "Question": "How do you create a set with elements 1, 2, 3?", "Answers": ["{1, 2, 3} or set([1, 2, 3])"], "IncorrectAnswers": ["[1, 2, 3]", "(1, 2, 3)", "set(1, 2, 3)", "<1, 2, 3>", "Set.new(1, 2, 3)", "array(1, 2, 3)"], "RegEx": "", "RegExDescription": ""}
{"id": "cbd54ca097176ccb108555b1fd53e53b", "QuestionId": 30, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Slice syntax is [start:stop:step] where stop is exclusive. list[1:4] gets indices 1, 2, 3 (not 4). This exclusive end behavior matches range() and is consistent across Python.", "Question": "What is list slicing syntax to get elements from index 1 to 3?", "Answers": ["list[1:4]"], "IncorrectAnswers": ["list[1:3]", "list[1-3]", "list.slice(1, 3)", "list(1, 3)", "list.get(1, 3)", "list{1:3}"], "RegEx": "", "RegExDescription": ""}
{"id": "2f074053c6a7703c29ad0012cd509b5d", "QuestionId": 31, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Python 3.9 introduced the | operator for merging dictionaries. For earlier versions, use {**dict1, **dict2} or dict1.update(dict2). The right operand's values override duplicates.", "Question": "How do you merge two dictionaries in Python 3.9+?", "Answers": ["dict1 | dict2"], "IncorrectAnswers": ["dict1 + dict2", "dict1.merge(dict2)", "merge(dict1, dict2)", "dict1 & dict2", "dict1.add(dict2)", "{**dict1, dict2}"], "RegEx": "", "RegExDescription": ""}
{"id": "7f145f0ca8a5e444536ecd7b2b788f14", "QuestionId": 32, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "list.sort() modifies the list in place and returns None. If you need a new sorted list while keeping the original unchanged, use sorted(list) instead, which returns a new list.", "Question": "What does list.sort() return?", "Answers": ["None (sorts in place)"], "IncorrectAnswers": ["The sorted list", "A new sorted list", "True if successful", "The length of list", "First element", "Last element"], "RegEx": "", "RegExDescription": ""}
{"id": "908af3d8b7e52e8c996ad437b615d9c0", "QuestionId": 33, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "range(10) generates numbers 0-9 (10 is exclusive). Wrapping in list() converts the range object to an actual list. range() is memory-efficient as it generates values on demand.", "Question": "How do you create a list of numbers 0-9?", "Answers": ["list(range(10))"], "IncorrectAnswers": ["[0-9]", "range(0, 9)", "list(0, 10)", "[0..9]", "seq(10)", "numbers(10)"], "RegEx": "", "RegExDescription": ""}
{"id": "2e5eb716c8db7f185056f83d27340709", "QuestionId": 34, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "append() adds its argument as a single element (even if it's a list). extend() iterates through its argument and adds each element individually. [1,2].append([3,4]) gives [1,2,[3,4]], while extend gives [1,2,3,4].", "Question": "What is the difference between append() and extend()?", "Answers": ["append() adds one element, extend() adds all elements from an iterable"], "IncorrectAnswers": ["They are the same", "extend() is faster", "append() creates a new list", "extend() only works with lists", "append() can add multiple items", "extend() adds at the beginning"], "RegEx": "", "RegExDescription": ""}
{"id": "72a7319da92d6ad7a42a9107426ac3b2", "QuestionId": 35, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "The 'in' operator checks key existence in O(1) time for dictionaries. This is preferred over dict.keys() or try/except because it's clear, Pythonic, and efficient.", "Question": "How do you check if a key exists in a dictionary?", "Answers": ["key in dict"], "IncorrectAnswers": ["dict.has(key)", "dict.contains(key)", "dict.exists(key)", "dict.hasKey(key)", "key.in(dict)", "dict.find(key)"], "RegEx": "", "RegExDescription": ""}
{"id": "1f7305378443810a9b22c1e773727f28", "QuestionId": 36, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "List comprehensions provide a compact syntax: [expression for item in iterable if condition]. Example: [x*2 for x in range(5)] creates [0, 2, 4, 6, 8]. They're often faster than equivalent for loops.", "Question": "What is a list comprehension?", "Answers": ["A concise way to create lists using a single line expression"], "IncorrectAnswers": ["A way to understand lists", "A list documentation tool", "A type of linked list", "A list sorting method", "A debugging technique", "A memory optimization"], "RegEx": "", "RegExDescription": ""}
{"id": "1f3f433c380877664a88bc6ddb9ccf53", "QuestionId": 37, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "list.reverse() reverses in place and returns None. For a reversed copy, use reversed(list) (returns iterator) or list[::-1] (returns new list). The slice method is often preferred for readability.", "Question": "How do you reverse a list in place?", "Answers": ["list.reverse()"], "IncorrectAnswers": ["reversed(list)", "list[::-1]", "list.flip()", "reverse(list)", "list.invert()", "list.backwards()"], "RegEx": "", "RegExDescription": ""}
{"id": "38f5024cfd3cb691d4f466c7a59825ff", "QuestionId": 38, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "dict.get(key, default) safely retrieves values without raising KeyError. If the key doesn't exist, it returns the default value (or None if no default specified). This is safer than direct key access.", "Question": "What does dict.get('key', 'default') do if key doesn't exist?", "Answers": ["Returns 'default' without raising an error"], "IncorrectAnswers": ["Raises KeyError", "Returns None", "Returns False", "Creates the key", "Returns empty string", "Crashes the program"], "RegEx": "", "RegExDescription": ""}
{"id": "99d09f9356041844151a99a804b6c956", "QuestionId": 39, "Difficulty": "L1", "Category": "Data_Structures", "Type": "multiple_choice", "Description": "Converting a list to a set removes duplicates since sets only contain unique elements. Converting back to list gives a deduplicated list. Note: this doesn't preserve original order in Python < 3.7.", "Question": "How do you remove duplicates from a list?", "Answers": ["list(set(original_list))"], "IncorrectAnswers": ["original_list.unique()", "unique(original_list)", "original_list.distinct()", "remove_duplicates(list)", "list.dedupe()", "filter(list)"], "RegEx": "", "RegExDescription": ""}
{"id": "a13ff4ef0e9d02043b97887db81d6faf", "QuestionId": 40, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Default parameters are assigned with = in the function definition. If the caller doesn't provide that argument, the default is used. Default parameters must come after non-default parameters.", "Question": "What is the syntax for a function with default parameter value?", "Answers": ["def func(param=value):"], "IncorrectAnswers": ["def func(param: value):", "def func(param == value):", "def func(value param):", "def func(param -> value):", "def func(default param=value):", "def func(param := value):"], "RegEx": "", "RegExDescription": ""}
{"id": "403e099275d6c18bf33ee50f633a14c6", "QuestionId": 41, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "*args collects extra positional arguments into a tuple. This allows functions to accept any number of arguments. Inside the function, args is a tuple containing all the extra positional arguments passed.", "Question": "What does *args represent in a function definition?", "Answers": ["Variable number of positional arguments as a tuple"], "IncorrectAnswers": ["A single required argument", "Keyword arguments only", "A list of strings", "Pointer to arguments", "Optional arguments", "Multiple return values"], "RegEx": "", "RegExDescription": ""}
{"id": "54660a04a71cf7b8d7917e7565aebe2b", "QuestionId": 42, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "**kwargs collects extra keyword arguments into a dictionary. The keys are argument names (strings), values are the passed values. This enables functions to accept arbitrary named parameters.", "Question": "What does **kwargs represent in a function definition?", "Answers": ["Variable number of keyword arguments as a dictionary"], "IncorrectAnswers": ["Double pointer to args", "Two required arguments", "Power of arguments", "Positional arguments only", "Configuration settings", "Class attributes"], "RegEx": "", "RegExDescription": ""}
{"id": "8cc9bae6af6fda14b2dc1a27f2c4f3e6", "QuestionId": 43, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Lambda functions are anonymous functions defined with the lambda keyword. They can only contain a single expression (no statements). Syntax: lambda arguments: expression. Often used with map(), filter(), and sort().", "Question": "What is a lambda function?", "Answers": ["An anonymous, single-expression function"], "IncorrectAnswers": ["A function that calls itself recursively", "A function that yields values one at a time", "A named function defined with the def keyword", "A function that runs concurrently using async", "A function that modifies another function's behavior", "A built-in function"], "RegEx": "", "RegExDescription": ""}
{"id": "750d65d5018b632dc66e500e4312e1ab", "QuestionId": 44, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Lambda syntax is: lambda parameters: expression. The expression is evaluated and returned. 'lambda x: x ** 2' takes x and returns x squared. Equivalent to def square(x): return x ** 2", "Question": "How do you write a lambda that squares a number?", "Answers": ["lambda x: x ** 2"], "IncorrectAnswers": ["lambda x: x ^ 2", "def lambda(x): x ** 2", "lambda(x) = x ** 2", "x => x ** 2", "lambda x -> x ** 2", "\\x -> x ** 2"], "RegEx": "", "RegExDescription": ""}
{"id": "2e03e1ac4739debf2abd87ad3ad6ea38", "QuestionId": 45, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "The return statement exits a function and optionally passes back a value to the caller. Without a return (or with just 'return'), the function returns None. Multiple values can be returned as a tuple.", "Question": "What is the purpose of the return statement?", "Answers": ["To exit a function and optionally send back a value"], "IncorrectAnswers": ["To print output", "To define variables", "To import modules", "To create loops", "To handle errors", "To define classes"], "RegEx": "", "RegExDescription": ""}
{"id": "18a2a1778f6207ec821552ac574af5b9", "QuestionId": 46, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Functions without an explicit return statement (or with just 'return') implicitly return None. This is Python's null value. If you need a meaningful return value, always include an explicit return statement.", "Question": "What does a function return if there is no return statement?", "Answers": ["None"], "IncorrectAnswers": ["0", "False", "Empty string", "Error", "undefined", "null"], "RegEx": "", "RegExDescription": ""}
{"id": "46c04094283c066113ed340367cfbf8c", "QuestionId": 47, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Docstrings are string literals placed as the first statement in a function, class, or module. They're accessible via the __doc__ attribute and are used by documentation tools and help() function.", "Question": "What is a docstring?", "Answers": ["A string literal as the first statement in a function to document it"], "IncorrectAnswers": ["A comment using #", "A type annotation", "A function parameter", "An error message", "A variable name", "A return type"], "RegEx": "", "RegExDescription": ""}
{"id": "2d661df97fc35de1128f4cddcf562651", "QuestionId": 48, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Functions are called by their name followed by parentheses containing arguments. Arguments are passed by position or by keyword (name=value). The parentheses are required even for functions with no arguments.", "Question": "How do you call a function named 'greet' with argument 'Alice'?", "Answers": ["greet('Alice')"], "IncorrectAnswers": ["greet 'Alice'", "call greet('Alice')", "greet['Alice']", "greet -> 'Alice'", "invoke greet('Alice')", "run greet('Alice')"], "RegEx": "", "RegExDescription": ""}
{"id": "70451c9694184328421fbad27afb2d5a", "QuestionId": 49, "Difficulty": "L1", "Category": "Functions", "Type": "multiple_choice", "Description": "Local scope means variables created inside a function only exist within that function. They're created when the function runs and destroyed when it returns. Use 'global' keyword to access/modify global variables.", "Question": "What is function scope in Python?", "Answers": ["Variables defined inside a function are local and not accessible outside"], "IncorrectAnswers": ["All variables are global", "Functions share all variables", "Scope doesn't exist in Python", "Variables persist after function ends", "Only constants have scope", "Scope only applies to classes"], "RegEx": "", "RegExDescription": ""}
{"id": "cfe9daed7cad81705c6db83bc1f9d034", "QuestionId": 50, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "Decorators are functions that wrap other functions to extend their behavior without modifying their code. They use the @decorator syntax and are commonly used for logging, authentication, caching, and more.", "Question": "What is a decorator in Python?", "Answers": ["A function that modifies the behavior of another function"], "IncorrectAnswers": ["A way to decorate output", "A class attribute", "A type of comment", "A testing framework", "A syntax highlighter", "A code formatter"], "RegEx": "", "RegExDescription": ""}
{"id": "6048d4c6d093deaaed85dbc7873a8c8f", "QuestionId": 51, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "The @decorator syntax is syntactic sugar for: function = decorator(function). Placing @decorator_name above a function definition automatically wraps that function with the decorator.", "Question": "How do you apply a decorator to a function?", "Answers": ["@decorator_name above the function definition"], "IncorrectAnswers": ["decorator_name(function)", "function.decorate()", "#decorator_name", "with decorator_name:", "use decorator_name", "import decorator_name"], "RegEx": "", "RegExDescription": ""}
{"id": "c86d4b72f444909933335c56ece62bc7", "QuestionId": 52, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "Closures occur when a nested function references variables from its enclosing scope. The inner function 'closes over' these variables, retaining access even after the outer function has finished executing.", "Question": "What is a closure in Python?", "Answers": ["A nested function that remembers values from its enclosing scope"], "IncorrectAnswers": ["A function decorated with @contextmanager", "A generator that yields multiple values", "A class method that accesses private attributes", "A try/finally block for resource management", "A way to close files", "A garbage collection method"], "RegEx": "", "RegExDescription": ""}
{"id": "4629c7d9baf1cb4f3a8c002616c5fe69", "QuestionId": 53, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "functools.partial freezes some arguments of a function, creating a new function with fewer parameters. Useful for adapting functions to APIs that expect specific signatures or for creating specialized versions.", "Question": "What does functools.partial do?", "Answers": ["Creates a new function with some arguments pre-filled"], "IncorrectAnswers": ["Splits a function in half", "Makes function run partially", "Creates incomplete functions", "Removes function arguments", "Tests part of a function", "Documents a function"], "RegEx": "", "RegExDescription": ""}
{"id": "371734bd53baa2288006564e0c111fd9", "QuestionId": 54, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "@staticmethod creates a method that doesn't receive the instance (self) or class (cls) as first argument. It's essentially a regular function that happens to live in a class's namespace for organizational purposes.", "Question": "What is the purpose of @staticmethod?", "Answers": ["Defines a method that doesn't access instance or class state"], "IncorrectAnswers": ["Defines a method that receives the class as first argument", "Caches the method's return value for repeated calls", "Makes the method only callable from the class, not instances", "Prevents the method from being overridden in subclasses", "Makes method faster", "Creates global method"], "RegEx": "", "RegExDescription": ""}
{"id": "a7d47db7f69c9c5085d24bb6c3997881", "QuestionId": 55, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "@classmethod receives the class (cls) as its first argument, allowing it to access class attributes and call other class methods. @staticmethod receives no implicit first argument - it's just a function inside a class.", "Question": "What is the difference between @staticmethod and @classmethod?", "Answers": ["@classmethod receives the class as first argument, @staticmethod doesn't"], "IncorrectAnswers": ["They are identical", "@staticmethod is faster", "@classmethod is deprecated", "@staticmethod uses self", "@classmethod is for testing", "No practical difference"], "RegEx": "", "RegExDescription": ""}
{"id": "6b738f624f7c86bea13282c8cfc7db37", "QuestionId": 56, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "Memoization stores function results so repeated calls with the same arguments return cached values instead of recomputing. This optimization is especially valuable for expensive recursive functions like Fibonacci.", "Question": "What is memoization?", "Answers": ["Caching function results to avoid redundant calculations"], "IncorrectAnswers": ["Storing function definitions in a dictionary", "Converting functions to use generators for efficiency", "Compiling functions to bytecode at import time", "Profiling function execution to find bottlenecks", "Memory allocation", "Variable naming convention"], "RegEx": "", "RegExDescription": ""}
{"id": "007aa03ecd17558d87c6e3271a11f3be", "QuestionId": 57, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "@functools.lru_cache (Least Recently Used cache) is a decorator that automatically memoizes function results. It stores up to maxsize recent calls. Python 3.9+ also has @functools.cache for unlimited caching.", "Question": "How do you implement memoization using functools?", "Answers": ["@functools.lru_cache"], "IncorrectAnswers": ["@functools.memo", "@functools.cache_result", "@functools.remember", "@functools.store", "@functools.save", "@functools.memory"], "RegEx": "", "RegExDescription": ""}
{"id": "287af3390f7bef99c76d2e7fd3e20665", "QuestionId": 58, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "The 'nonlocal' keyword allows a nested function to rebind variables in an enclosing (but non-global) scope. Without it, assignment creates a new local variable instead of modifying the outer one.", "Question": "What does the 'nonlocal' keyword do?", "Answers": ["Allows a nested function to modify a variable in the enclosing scope"], "IncorrectAnswers": ["Declares a global variable", "Creates a local variable", "Deletes a variable", "Imports external modules", "Defines constants", "Prevents variable access"], "RegEx": "", "RegExDescription": ""}
{"id": "aa7c604003e8afc1fc7cc06b0b244daa", "QuestionId": 59, "Difficulty": "L2", "Category": "Functions", "Type": "multiple_choice", "Description": "Higher-order functions treat functions as first-class citizens - they can accept functions as arguments and/or return functions. Examples include map(), filter(), sorted() with key parameter, and decorators.", "Question": "What is a higher-order function?", "Answers": ["A function that takes or returns other functions"], "IncorrectAnswers": ["A function in a higher class", "A more important function", "A function with more parameters", "A recursive function", "A faster function", "An optimized function"], "RegEx": "", "RegExDescription": ""}
{"id": "8dfdaf7c3678654d104d8310712c0e70", "QuestionId": 60, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Classes are defined with the 'class' keyword followed by the class name (conventionally in PascalCase) and a colon. The class body is indented and contains methods and attributes.", "Question": "How do you define a class in Python?", "Answers": ["class ClassName:"], "IncorrectAnswers": ["def class ClassName:", "new class ClassName:", "create class ClassName:", "Class ClassName:", "define class ClassName:", "struct ClassName:"], "RegEx": "", "RegExDescription": ""}
{"id": "b3082d8f9c1916ffdf452cae4b580d97", "QuestionId": 61, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "__init__ is the constructor method called automatically when creating a new instance. It initializes the object's attributes. The first parameter is always 'self', referring to the instance being created.", "Question": "What is the purpose of __init__ method?", "Answers": ["To initialize object attributes when an instance is created"], "IncorrectAnswers": ["To destroy the object", "To inherit from parent", "To create static methods", "To define class variables", "To import modules", "To validate data"], "RegEx": "", "RegExDescription": ""}
{"id": "d8bbadbf6709532dc90885c2ef890ba2", "QuestionId": 62, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "'self' is a reference to the current instance of the class. It's used to access instance attributes and methods. While 'self' is a convention (not a keyword), it's universally followed in Python.", "Question": "What does 'self' refer to in a class method?", "Answers": ["The current instance of the class"], "IncorrectAnswers": ["The class itself", "The parent class", "The method name", "A global variable", "The constructor", "The return value"], "RegEx": "", "RegExDescription": ""}
{"id": "c41138d5a0ac659291de3dd046d916d3", "QuestionId": 63, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Instances are created by calling the class like a function. Python doesn't use 'new' keyword. Dog() calls __new__ (creates the object) then __init__ (initializes it), returning the new instance.", "Question": "How do you create an instance of class 'Dog'?", "Answers": ["dog = Dog()"], "IncorrectAnswers": ["dog = new Dog()", "dog = Dog.new()", "dog = create Dog()", "dog = instance Dog()", "dog = Dog.create()", "dog := Dog()"], "RegEx": "", "RegExDescription": ""}
{"id": "3c1f7e30801264283a1e8345cf403b23", "QuestionId": 64, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Inheritance is specified by putting the parent class in parentheses after the child class name. The child inherits all attributes and methods from the parent and can override or extend them.", "Question": "How do you inherit from a parent class?", "Answers": ["class Child(Parent):"], "IncorrectAnswers": ["class Child extends Parent:", "class Child inherits Parent:", "class Child : Parent:", "class Child <- Parent:", "class Child from Parent:", "class Child < Parent:"], "RegEx": "", "RegExDescription": ""}
{"id": "7d56f2b9b8ed7439719496a3f0e1862d", "QuestionId": 65, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Encapsulation groups related data (attributes) and behavior (methods) into a single unit (class), and controls access to internal details. This promotes modularity and protects data integrity.", "Question": "What is encapsulation in OOP?", "Answers": ["Bundling data and methods that operate on that data within a class"], "IncorrectAnswers": ["Hiding all code", "Encrypting class data", "Creating multiple classes", "Splitting classes apart", "Copying class instances", "Deleting private data"], "RegEx": "", "RegExDescription": ""}
{"id": "a3f97698740314b7e64735a478eb381f", "QuestionId": 66, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Python uses naming conventions for access control. Single underscore (_attr) suggests 'protected' (internal use). Double underscore (__attr) triggers name mangling, making it harder to access from outside the class.", "Question": "How do you indicate a private attribute in Python?", "Answers": ["Prefix with underscore (_attribute or __attribute)"], "IncorrectAnswers": ["Use 'private' keyword", "Use # symbol", "Use 'protected' keyword", "Put in brackets", "Use @ symbol", "Use 'hidden' keyword"], "RegEx": "", "RegExDescription": ""}
{"id": "2f6f4c810c0ff62fa817d911a5eb8ce7", "QuestionId": 67, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Polymorphism allows different classes to implement the same method name with different behaviors. Code can call the method without knowing the specific class, and the appropriate implementation runs based on the object's actual type.", "Question": "What is polymorphism?", "Answers": ["The ability of different classes to be treated through the same interface"], "IncorrectAnswers": ["Creating many classes", "Changing variable types", "Multiple inheritance only", "Class naming convention", "Object destruction", "Memory management"], "RegEx": "", "RegExDescription": ""}
{"id": "999cb65247f73c712e680f4f2583738f", "QuestionId": 68, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "super() returns a proxy object that delegates method calls to the parent class. In __init__, super().__init__() ensures the parent's initialization runs. This is essential for proper inheritance chains.", "Question": "How do you call the parent class's __init__ method?", "Answers": ["super().__init__()"], "IncorrectAnswers": ["parent.__init__()", "Parent.__init__()", "self.parent.__init__()", "base.__init__()", "init.parent()", "this.super().__init__()"], "RegEx": "", "RegExDescription": ""}
{"id": "d98a42343c1c67aad90787acb8ce4342", "QuestionId": 69, "Difficulty": "L1", "Category": "OOP", "Type": "multiple_choice", "Description": "Class attributes are defined directly in the class body and shared by all instances. Instance attributes are defined in __init__ (or other methods) using self and are unique to each instance.", "Question": "What is a class attribute vs instance attribute?", "Answers": ["Class attributes are shared by all instances, instance attributes are unique to each"], "IncorrectAnswers": ["They are the same thing", "Class attributes are private", "Instance attributes are global", "Class attributes can't change", "Instance attributes are faster", "Class attributes are temporary"], "RegEx": "", "RegExDescription": ""}
{"id": "0d49139f06ea125adac5b7faab28d2d4", "QuestionId": 70, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "MRO defines the order Python searches for methods in class hierarchies, especially with multiple inheritance. It uses the C3 linearization algorithm. View it with ClassName.__mro__ or ClassName.mro().", "Question": "What is the Method Resolution Order (MRO)?", "Answers": ["The order in which Python looks up methods in a class hierarchy"], "IncorrectAnswers": ["A sorting algorithm", "A design pattern", "A debugging tool", "A compilation step", "A naming convention", "A test framework"], "RegEx": "", "RegExDescription": ""}
{"id": "5383f85eb029a52d181b5a0cc08a4bab", "QuestionId": 71, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "@property creates a getter method that's accessed like an attribute (obj.name instead of obj.get_name()). You can add @name.setter and @name.deleter for write and delete operations, enabling controlled attribute access.", "Question": "What is the @property decorator used for?", "Answers": ["To create getter/setter methods that look like attribute access"], "IncorrectAnswers": ["To declare class properties", "To create constants", "To initialize attributes", "To make attributes public", "To delete attributes", "To copy attributes"], "RegEx": "", "RegExDescription": ""}
{"id": "4a628a5f17d112b1e5a93e6ecf9c1f36", "QuestionId": 72, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "ABCs from the abc module define interfaces that subclasses must implement. You can't instantiate an ABC directly - it's a template. Subclasses must implement all @abstractmethod methods or they also become abstract.", "Question": "What is an abstract base class (ABC)?", "Answers": ["A class that cannot be instantiated and defines methods subclasses must implement"], "IncorrectAnswers": ["A simple base class", "A class with no methods", "A deprecated class type", "A compiled class", "A testing class", "A utility class"], "RegEx": "", "RegExDescription": ""}
{"id": "423e80b07ed43dd6a68c7239c8b0cb47", "QuestionId": 73, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "Import ABC and abstractmethod from the abc module. Inherit from ABC and decorate methods with @abstractmethod. Abstract methods can have implementations that subclasses can call with super().", "Question": "How do you create an abstract method?", "Answers": ["Use @abstractmethod decorator from abc module"], "IncorrectAnswers": ["Use 'abstract' keyword", "Leave method body empty", "Use @virtual decorator", "Use 'interface' keyword", "Prefix with _abstract_", "Use pass statement only"], "RegEx": "", "RegExDescription": ""}
{"id": "2dcb8394e516c1757a13b4f5adc3ec10", "QuestionId": 74, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "Dunder (double underscore) methods like __init__, __str__, __add__ let you customize how objects behave with built-in operations. They're called by Python's syntax (e.g., + calls __add__, str() calls __str__).", "Question": "What are dunder (magic) methods?", "Answers": ["Special methods with double underscores that customize class behavior"], "IncorrectAnswers": ["Secret hidden methods", "Debugging methods", "Private utility methods", "Deprecated methods", "Testing methods", "Performance methods"], "RegEx": "", "RegExDescription": ""}
{"id": "cc7045b5da7e44d6d29a752e8c9aed4c", "QuestionId": 75, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "__str__ is called by str() and print() to get a user-friendly string representation. It should return a readable string suitable for end users. If not defined, Python falls back to __repr__.", "Question": "What does __str__ method do?", "Answers": ["Defines the human-readable string representation of an object"], "IncorrectAnswers": ["Converts object to string", "Validates string input", "Counts characters", "Concatenates strings", "Formats string output", "Encrypts strings"], "RegEx": "", "RegExDescription": ""}
{"id": "0f51f20f06c23d975742bad0d588a180", "QuestionId": 76, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "__repr__ should return an unambiguous representation, ideally valid Python code to recreate the object. It's for developers and debugging. __str__ is for users. When __str__ is missing, __repr__ is used.", "Question": "What is the difference between __str__ and __repr__?", "Answers": ["__str__ is for end users, __repr__ is for developers/debugging"], "IncorrectAnswers": ["They are identical", "__repr__ is deprecated", "__str__ is private", "__repr__ returns integers", "__str__ is for files", "__repr__ is for printing"], "RegEx": "", "RegExDescription": ""}
{"id": "550e5d746852b9e4eeca2509f77fdc58", "QuestionId": 77, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "Multiple inheritance allows a class to inherit from multiple parent classes: class Child(Parent1, Parent2). Python uses MRO to resolve method lookups. It's powerful but can lead to complexity (the 'diamond problem').", "Question": "What is multiple inheritance?", "Answers": ["A class inheriting from more than one parent class"], "IncorrectAnswers": ["Creating multiple instances", "Inheriting multiple times", "Having multiple __init__", "Creating child classes", "Overriding multiple methods", "Using multiple modules"], "RegEx": "", "RegExDescription": ""}
{"id": "a5a289fe8b278ee280e831dda28483b6", "QuestionId": 78, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "Mixins are classes designed to provide specific functionality to other classes through inheritance. They're not meant to stand alone. Example: LoggingMixin might add logging to any class that inherits it.", "Question": "What is a mixin class?", "Answers": ["A class designed to add specific functionality to other classes via inheritance"], "IncorrectAnswers": ["A class that mixes data types", "A random class generator", "A testing utility class", "A deprecated class type", "A compiled class", "A virtual class"], "RegEx": "", "RegExDescription": ""}
{"id": "c9d814e4ffaa59e5f6c99e04d073d376", "QuestionId": 79, "Difficulty": "L2", "Category": "OOP", "Type": "multiple_choice", "Description": "__slots__ declares a fixed set of attributes, preventing dynamic attribute creation and eliminating the per-instance __dict__. This saves memory for classes with many instances and slightly speeds up attribute access.", "Question": "What does __slots__ do?", "Answers": ["Restricts instance attributes to save memory and improve access speed"], "IncorrectAnswers": ["Creates time slots", "Defines method slots", "Limits inheritance", "Enables threading", "Creates database slots", "Defines array size"], "RegEx": "", "RegExDescription": ""}
{"id": "2a614feb49f3534a0cc870f9ce3bcfe3", "QuestionId": 80, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The import statement loads a module and makes its contents available. After 'import math', access functions with math.sqrt(), math.pi, etc. This keeps the namespace clean and shows where functions come from.", "Question": "How do you import a module named 'math'?", "Answers": ["import math"], "IncorrectAnswers": ["include math", "require math", "using math", "load math", "get math", "#import math"], "RegEx": "", "RegExDescription": ""}
{"id": "b1d03a32a1e00aa1e626bb321118c7b7", "QuestionId": 81, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "'from module import name' imports specific items directly into your namespace. After this, use sqrt() directly instead of math.sqrt(). Be careful not to shadow built-in names with imported ones.", "Question": "How do you import only the 'sqrt' function from math?", "Answers": ["from math import sqrt"], "IncorrectAnswers": ["import sqrt from math", "import math.sqrt", "math import sqrt", "include math.sqrt", "get sqrt from math", "using math.sqrt"], "RegEx": "", "RegExDescription": ""}
{"id": "897e65d7a28e7f6af5f61337c0cb68bf", "QuestionId": 82, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The 'as' keyword creates an alias for the imported module. Common examples: import numpy as np, import pandas as pd. This shortens repeated usage and is a widely-followed convention in data science.", "Question": "How do you give a module an alias when importing?", "Answers": ["import module as alias"], "IncorrectAnswers": ["import module = alias", "import module -> alias", "import module : alias", "alias = import module", "import module alias", "import module(alias)"], "RegEx": "", "RegExDescription": ""}
{"id": "4dcc3d9dd34107ea9b6805e19ac80283", "QuestionId": 83, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "pip (Pip Installs Packages) is Python's standard package manager. It downloads and installs packages from PyPI (Python Package Index). It handles dependencies automatically and can install specific versions.", "Question": "What is pip?", "Answers": ["Python's package installer for installing third-party packages"], "IncorrectAnswers": ["Python interpreter", "Python IDE", "Python debugger", "Python compiler", "Python editor", "Python formatter"], "RegEx": "", "RegExDescription": ""}
{"id": "f217bbde7b1262271fecd68905e6c0a4", "QuestionId": 84, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "pip install downloads packages from PyPI and installs them. Add version specifiers like pip install package==1.0.0 for specific versions. Use pip install -r requirements.txt to install from a file.", "Question": "How do you install a package using pip?", "Answers": ["pip install package_name"], "IncorrectAnswers": ["pip get package_name", "pip add package_name", "pip download package_name", "pip load package_name", "pip fetch package_name", "pip setup package_name"], "RegEx": "", "RegExDescription": ""}
{"id": "92de03b5cfb062fc5fefa98d03e06f00", "QuestionId": 85, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "When a script runs directly, __name__ is set to '__main__'. When imported as a module, __name__ is the module's name. This idiom lets a file work both as a script and an importable module.", "Question": "What is __name__ == '__main__' used for?", "Answers": ["To run code only when the script is executed directly, not imported"], "IncorrectAnswers": ["To name the program", "To define the main function", "To create entry point", "To import main module", "To check module name", "To validate script"], "RegEx": "", "RegExDescription": ""}
{"id": "39af6d533074fa1eb544dfd929dbf4f0", "QuestionId": 86, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "os.path provides functions like join(), exists(), dirname() for path manipulation. pathlib (Python 3.4+) offers an object-oriented approach with Path objects. pathlib is more modern and often preferred.", "Question": "Which module provides functions for working with file paths?", "Answers": ["os.path or pathlib"], "IncorrectAnswers": ["filepath", "path", "files", "io", "system", "directory"], "RegEx": "", "RegExDescription": ""}
{"id": "9c6b20c1c66fe900b7df574756cd059e", "QuestionId": 87, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The json module handles JSON encoding and decoding. It converts between Python objects (dicts, lists) and JSON strings. It's part of the standard library and is essential for API work and configuration files.", "Question": "Which module is used for working with JSON data?", "Answers": ["json"], "IncorrectAnswers": ["jsonlib", "simplejson", "data", "serialize", "parser", "objects"], "RegEx": "", "RegExDescription": ""}
{"id": "b68683de2b128f6ef09849b803475b90", "QuestionId": 88, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "json.load(file) reads from a file object. json.loads(string) parses a string (the 's' stands for 'string'). Similarly, json.dump() writes to files and json.dumps() returns a string.", "Question": "What function reads a JSON file in Python?", "Answers": ["json.load() for files, json.loads() for strings"], "IncorrectAnswers": ["json.read()", "json.parse()", "json.open()", "json.get()", "json.decode()", "json.import()"], "RegEx": "", "RegExDescription": ""}
{"id": "de93244ba700c22e7295a51089b8e6a0", "QuestionId": 89, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The datetime module provides classes for date and time manipulation: datetime (combined), date (date only), time (time only), and timedelta (duration). It handles parsing, formatting, and arithmetic.", "Question": "Which module provides the datetime class?", "Answers": ["datetime"], "IncorrectAnswers": ["time", "date", "calendar", "clock", "moment", "period"], "RegEx": "", "RegExDescription": ""}
{"id": "636a3391a5f2b1fab7f6004de2641f64", "QuestionId": 90, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "datetime.datetime.now() returns the current local date and time. For UTC, use datetime.datetime.utcnow(). For timezone-aware datetimes in Python 3.9+, use datetime.datetime.now(datetime.timezone.utc).", "Question": "How do you get the current date and time?", "Answers": ["datetime.datetime.now()"], "IncorrectAnswers": ["datetime.current()", "time.now()", "date.today()", "datetime.time()", "now()", "current_time()"], "RegEx": "", "RegExDescription": ""}
{"id": "65278434e0541bb30cd4412320994e5f", "QuestionId": 91, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The re module provides regular expression operations. Key functions: re.search() finds first match, re.match() checks start of string, re.findall() returns all matches, re.sub() replaces matches.", "Question": "Which module provides regular expression support?", "Answers": ["re"], "IncorrectAnswers": ["regex", "regexp", "pattern", "match", "search", "find"], "RegEx": "", "RegExDescription": ""}
{"id": "18358142afbf891f49c9d33f9f00d497", "QuestionId": 92, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "random.randint(a, b) returns a random integer N where a <= N <= b (inclusive on both ends). For exclusive end, use random.randrange(). For floats, use random.random() (0 to 1) or random.uniform(a, b).", "Question": "How do you generate a random integer between 1 and 10?", "Answers": ["random.randint(1, 10)"], "IncorrectAnswers": ["random.int(1, 10)", "random.range(1, 10)", "random(1, 10)", "randint(1, 10)", "random.number(1, 10)", "random.between(1, 10)"], "RegEx": "", "RegExDescription": ""}
{"id": "4dedbfd0075a84141e73ca4b5d23c4d2", "QuestionId": 93, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "Virtual environments create isolated Python installations with their own packages. This prevents dependency conflicts between projects. Each project can have different versions of the same package.", "Question": "What is a virtual environment?", "Answers": ["An isolated Python environment with its own packages and interpreter"], "IncorrectAnswers": ["A virtual machine", "A cloud server", "A testing sandbox", "A Docker container", "A simulation mode", "A debug environment"], "RegEx": "", "RegExDescription": ""}
{"id": "5fa58e9e93d9839f1edcadbbb7a84589", "QuestionId": 94, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "python -m venv creates a virtual environment directory containing a Python interpreter and pip. Activate it with source env/bin/activate (Linux/Mac) or env\\Scripts\\activate (Windows) before installing packages.", "Question": "How do you create a virtual environment?", "Answers": ["python -m venv env_name"], "IncorrectAnswers": ["virtualenv create env_name", "python --venv env_name", "pip create venv", "python new venv", "create venv env_name", "venv --new env_name"], "RegEx": "", "RegExDescription": ""}
{"id": "0fc158d8934767f599f989523de13859", "QuestionId": 95, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "requirements.txt lists project dependencies, one per line, optionally with version constraints (package==1.0.0). Generate it with 'pip freeze > requirements.txt' and install with 'pip install -r requirements.txt'.", "Question": "What file lists project dependencies for pip?", "Answers": ["requirements.txt"], "IncorrectAnswers": ["dependencies.txt", "packages.txt", "pip.txt", "install.txt", "modules.txt", "imports.txt"], "RegEx": "", "RegExDescription": ""}
{"id": "1ed5b147335d42d35ff7a88b13d59dff", "QuestionId": 96, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The requests library (third-party, install with pip) is the most popular HTTP library. The standard library's urllib works but is more complex. requests provides simple methods: get(), post(), put(), delete().", "Question": "Which module is used for making HTTP requests?", "Answers": ["requests (third-party) or urllib"], "IncorrectAnswers": ["http", "web", "fetch", "curl", "network", "internet"], "RegEx": "", "RegExDescription": ""}
{"id": "f82e4d55642daaa4e68dc0693fa19a69", "QuestionId": 97, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "shutil (shell utilities) provides high-level file operations. shutil.copy() copies file content and permissions. shutil.copy2() also preserves metadata. shutil.copytree() copies entire directories.", "Question": "How do you copy a file using Python?", "Answers": ["shutil.copy(src, dst)"], "IncorrectAnswers": ["os.copy(src, dst)", "file.copy(src, dst)", "copy(src, dst)", "io.copy(src, dst)", "fs.copy(src, dst)", "copyfile(src, dst)"], "RegEx": "", "RegExDescription": ""}
{"id": "8d0c7c440a18d15484119ed1fb6caef1", "QuestionId": 98, "Difficulty": "L1", "Category": "Modules", "Type": "multiple_choice", "Description": "The sys module provides access to Python interpreter variables and functions. sys.argv contains command-line arguments, sys.path lists module search paths, sys.exit() terminates the program.", "Question": "Which module provides system-specific parameters and functions?", "Answers": ["sys"], "IncorrectAnswers": ["os", "system", "platform", "config", "runtime", "env"], "RegEx": "", "RegExDescription": ""}
{"id": "b4613ce189ce064613ce13a178fe64f4", "QuestionId": 99, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Generators are functions that yield values one at a time using the yield keyword. They're memory-efficient for large sequences because they compute values on-demand rather than storing them all in memory.", "Question": "What is a generator in Python?", "Answers": ["A function that yields values one at a time, maintaining state between calls"], "IncorrectAnswers": ["A class that creates objects", "A module that generates code", "A random number creator", "A testing tool", "A file creator", "A loop optimizer"], "RegEx": "", "RegExDescription": ""}
{"id": "42b2b539f05c62702fabdf9133c8e9bf", "QuestionId": 100, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "The yield keyword pauses the function and returns a value. When next() is called on the generator, execution resumes from where it left off. This enables lazy evaluation and efficient memory usage.", "Question": "What keyword is used to create a generator?", "Answers": ["yield"], "IncorrectAnswers": ["generate", "return", "next", "iter", "produce", "emit"], "RegEx": "", "RegExDescription": ""}
{"id": "457c909f3cf225ac408eb4ba3afc1d12", "QuestionId": 101, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Context managers handle setup and cleanup automatically. The 'with' statement ensures resources are properly managed - files get closed, locks get released, even if exceptions occur. They implement __enter__ and __exit__.", "Question": "What is a context manager?", "Answers": ["An object that manages resources and is used with the 'with' statement"], "IncorrectAnswers": ["A class manager", "A memory allocator", "A thread coordinator", "A module loader", "A variable scope", "A debug tool"], "RegEx": "", "RegExDescription": ""}
{"id": "251cbc3ecb4c5e523964e9e8d111ada3", "QuestionId": 102, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "__enter__ runs when entering the 'with' block (can return a value assigned with 'as'). __exit__ runs when exiting (even on exception), receiving exception info. It can suppress exceptions by returning True.", "Question": "Which methods must a context manager implement?", "Answers": ["__enter__ and __exit__"], "IncorrectAnswers": ["__start__ and __stop__", "__open__ and __close__", "__begin__ and __end__", "__init__ and __del__", "__with__ and __end__", "__context__ and __exit__"], "RegEx": "", "RegExDescription": ""}
{"id": "28b8cf7204b166c0c7091fff5783bc86", "QuestionId": 103, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "async/await enables asynchronous programming for I/O-bound tasks. While waiting for I/O (network, file), other code can run. It's not parallel execution but cooperative multitasking within a single thread.", "Question": "What is async/await used for?", "Answers": ["Asynchronous programming to handle concurrent operations"], "IncorrectAnswers": ["Multithreading only", "Error handling", "Memory management", "Code compilation", "Type checking", "Debugging async code"], "RegEx": "", "RegExDescription": ""}
{"id": "d2fb275b839be61532914e373c482f6b", "QuestionId": 104, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "async def defines a coroutine function. It returns a coroutine object that must be awaited or run with asyncio.run(). Inside, you can use 'await' to pause and wait for other coroutines.", "Question": "How do you define an async function?", "Answers": ["async def function_name():"], "IncorrectAnswers": ["def async function_name():", "function async function_name():", "@async def function_name():", "define async function_name():", "async function function_name():", "await def function_name():"], "RegEx": "", "RegExDescription": ""}
{"id": "d5bcc0b7730a74dd775f0bc1d30da8bf", "QuestionId": 105, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "The GIL ensures only one thread executes Python bytecode at a time, even on multi-core systems. This simplifies memory management but limits CPU-bound parallelism. Use multiprocessing to bypass the GIL.", "Question": "What is the GIL (Global Interpreter Lock)?", "Answers": ["A mutex preventing multiple threads from executing Python bytecode simultaneously"], "IncorrectAnswers": ["A security feature", "A memory lock system", "A file locking mechanism", "A database lock", "A network protocol", "A compilation lock"], "RegEx": "", "RegExDescription": ""}
{"id": "ddd091cb84727cb9111b13ab3721f0cf", "QuestionId": 106, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Threading runs multiple threads in one process, sharing memory but limited by the GIL for CPU work. Multiprocessing runs separate processes with their own memory and GIL, enabling true parallelism on multiple cores.", "Question": "What is the difference between threading and multiprocessing?", "Answers": ["Threading shares memory and is limited by GIL; multiprocessing uses separate processes"], "IncorrectAnswers": ["They are identical", "Threading is faster", "Multiprocessing uses threads", "Threading uses more memory", "Multiprocessing is deprecated", "Threading runs parallel always"], "RegEx": "", "RegExDescription": ""}
{"id": "8f03c7d5f422806a9810cf2a50610fbf", "QuestionId": 107, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Metaclasses are 'classes of classes' - they define how classes behave. When you create a class, Python uses its metaclass (default: type) to construct it. Metaclasses can customize class creation and behavior.", "Question": "What is a metaclass?", "Answers": ["A class of a class that defines how classes behave"], "IncorrectAnswers": ["A deprecated class type", "An abstract class", "A parent class", "A utility class", "A testing class", "A data class"], "RegEx": "", "RegExDescription": ""}
{"id": "6e556fbfd0a2a1e95e83bbb8ee0501c6", "QuestionId": 108, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Pass metaclass= in the class definition. The metaclass must be a callable that accepts (name, bases, namespace) and returns a class. It can modify the class before it's created, add methods, or validate attributes.", "Question": "How do you specify a metaclass for a class?", "Answers": ["class MyClass(metaclass=MyMeta):"], "IncorrectAnswers": ["@metaclass(MyMeta)", "class MyClass(MyMeta):", "class MyClass meta MyMeta:", "MyMeta class MyClass:", "class MyClass with MyMeta:", "class MyClass using MyMeta:"], "RegEx": "", "RegExDescription": ""}
{"id": "98d749389d5668e128f89e01043b51d5", "QuestionId": 109, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "__getattr__ is called only when the attribute isn't found through normal means (instance dict, class, parent classes). It's a fallback for missing attributes. __getattribute__ is called for every attribute access.", "Question": "What is __getattr__ used for?", "Answers": ["Called when an attribute is not found through normal lookup"], "IncorrectAnswers": ["Gets all attributes", "Creates new attributes", "Validates attributes", "Lists attributes", "Deletes attributes", "Copies attributes"], "RegEx": "", "RegExDescription": ""}
{"id": "a1f4be69142b07422844fd188ab65bf9", "QuestionId": 110, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Descriptors are objects with __get__, __set__, or __delete__ methods that customize how attributes are accessed on other objects. Properties, class methods, and static methods are implemented using descriptors.", "Question": "What is a descriptor in Python?", "Answers": ["An object defining __get__, __set__, or __delete__ to customize attribute access"], "IncorrectAnswers": ["A documentation string", "A type annotation", "A variable description", "A class comment", "A module summary", "A function signature"], "RegEx": "", "RegExDescription": ""}
{"id": "9837e40ecfee2d19423929c2addabf37", "QuestionId": 111, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "The walrus operator (:=) introduced in Python 3.8 assigns a value to a variable as part of an expression. Useful in while loops and comprehensions: while (line := file.readline()): or [y for x in data if (y := f(x)) > 0]", "Question": "What is the walrus operator (:=)?", "Answers": ["An assignment expression that assigns and returns a value in one expression"], "IncorrectAnswers": ["A comparison operator", "A type casting operator", "A string formatting operator", "A bitwise operator", "A logical operator", "A null check operator"], "RegEx": "", "RegExDescription": ""}
{"id": "3ff3e6d97aec427751faca6e45703816", "QuestionId": 112, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Type hints (PEP 484) are optional annotations for function parameters and return types. Python doesn't enforce them at runtime, but tools like mypy use them for static type checking, improving code quality and IDE support.", "Question": "What is type hinting in Python?", "Answers": ["Optional annotations indicating expected types of variables and return values"], "IncorrectAnswers": ["Required type declarations", "Type enforcement at runtime", "Automatic type conversion", "Type error checking", "Compiled type safety", "Dynamic typing system"], "RegEx": "", "RegExDescription": ""}
{"id": "50d8da205a0397a8080ece6b2cbc3906", "QuestionId": 113, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Parameter types go after colons (x: int), return type after arrow (-> str). Use typing module for complex types: List[int], Dict[str, int], Optional[str], Union[int, str], Callable[[int], bool].", "Question": "How do you annotate a function that takes an int and returns a str?", "Answers": ["def func(x: int) -> str:"], "IncorrectAnswers": ["def func(int x) -> str:", "def func(x) -> int, str:", "def func(x: int): str", "def func<int>(x) -> str:", "def func(x as int) -> str:", "def func(x: int) returns str:"], "RegEx": "", "RegExDescription": ""}
{"id": "d0ebf1b0dffc4941d99426100f1ab573", "QuestionId": 114, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Dataclasses (Python 3.7+) reduce boilerplate for classes that mainly store data. The @dataclass decorator auto-generates __init__, __repr__, __eq__ and more based on class attributes with type annotations.", "Question": "What is dataclasses module used for?", "Answers": ["Automatically generating __init__, __repr__, and other methods for classes"], "IncorrectAnswers": ["Creating databases", "Storing data files", "Managing data types", "Parsing data formats", "Validating data input", "Encrypting data"], "RegEx": "", "RegExDescription": ""}
{"id": "bfa80e79c883a2dc04a9bba5ec90470e", "QuestionId": 115, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "@dataclass generates methods based on field definitions. Parameters control behavior: frozen=True makes instances immutable, order=True adds comparison methods. Fields can have defaults using field() for mutable defaults.", "Question": "What does @dataclass decorator do?", "Answers": ["Automatically generates special methods based on class attributes"], "IncorrectAnswers": ["Creates database tables", "Validates data types", "Serializes objects", "Creates data files", "Encrypts class data", "Compresses attributes"], "RegEx": "", "RegExDescription": ""}
{"id": "70b899ab184c02e5bb397f2060b3d498", "QuestionId": 116, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Shallow copy (copy.copy()) creates a new object but references the same nested objects. Deep copy (copy.deepcopy()) recursively copies all nested objects, creating completely independent copies. Use deep copy for nested mutable objects.", "Question": "What is the difference between deepcopy and shallow copy?", "Answers": ["Deepcopy creates copies of nested objects; shallow copy only copies references"], "IncorrectAnswers": ["They are identical", "Deepcopy is faster", "Shallow copy uses more memory", "Deepcopy only works on lists", "Shallow copy creates new objects", "Deepcopy is deprecated"], "RegEx": "", "RegExDescription": ""}
{"id": "43564b49e67ffbe282faee33a81cfd47", "QuestionId": 117, "Difficulty": "L2", "Category": "Advanced", "Type": "multiple_choice", "Description": "Monkey patching modifies modules or classes at runtime, adding or replacing attributes/methods. Useful for testing (mocking) or fixing third-party code, but can make code harder to understand and maintain.", "Question": "What is monkey patching?", "Answers": ["Dynamically modifying a module or class at runtime"], "IncorrectAnswers": ["A testing technique", "A debugging method", "An optimization strategy", "A documentation style", "A naming convention", "A deployment method"], "RegEx": "", "RegExDescription": ""}
{"id": "a1b2c3d4e5f6071829304050607a8b9d", "QuestionId": 118, "Difficulty": "L3", "Category": "Advanced", "Type": "multiple_choice", "Description": "__new__ is called before __init__ to create the instance. It receives the class and returns a new instance. Override it for immutable types (str, int, tuple) or to implement singletons/object caching.", "Question": "What is the difference between __new__ and __init__?", "Answers": ["__new__ creates the instance and returns it; __init__ initializes the already-created instance"], "IncorrectAnswers": ["They are the same method", "__init__ is called first", "__new__ is for old-style classes", "__init__ returns the instance", "__new__ only works with metaclasses", "__init__ creates the instance"], "RegEx": "", "RegExDescription": ""}
{"id": "b2c3d4e5f6a7182930405060718a9b0d", "QuestionId": 119, "Difficulty": "L3", "Category": "Advanced", "Type": "multiple_choice", "Description": "Iterator protocol requires __iter__ (returns self) and __next__ (returns next value or raises StopIteration). Iterables only need __iter__ returning an iterator. Generators automatically implement iterator protocol.", "Question": "What methods must an iterator implement?", "Answers": ["__iter__ (returns self) and __next__ (returns next value or raises StopIteration)"], "IncorrectAnswers": ["Only __next__", "Only __iter__", "__iterate__ and __next__", "__iter__ and __yield__", "__start__ and __next__", "__iter__ and __stop__"], "RegEx": "", "RegExDescription": ""}
{"id": "c3d4e5f6a7b8293040506071829a0b1d", "QuestionId": 120, "Difficulty": "L3", "Category": "Memory", "Type": "multiple_choice", "Description": "CPython uses reference counting for immediate cleanup plus generational garbage collection for cycles. gc.collect() forces collection. gc.get_referrers() and gc.get_referents() help debug reference cycles.", "Question": "How does Python's garbage collector handle reference cycles?", "Answers": ["Generational garbage collector detects and cleans up circular references"], "IncorrectAnswers": ["Reference counting handles all cases", "Cycles are never cleaned up", "Manual deallocation is required", "Cycles cause memory leaks always", "Only weak references break cycles", "The OS handles memory cleanup"], "RegEx": "", "RegExDescription": ""}
{"id": "d4e5f6a7b8c9304050607182930a1b2d", "QuestionId": 121, "Difficulty": "L3", "Category": "Memory", "Type": "multiple_choice", "Description": "weakref.ref creates a reference that doesn't prevent garbage collection. Access the object with ref() - returns None if collected. Useful for caches, observers, and avoiding circular references.", "Question": "What is a weak reference in Python?", "Answers": ["A reference that doesn't prevent garbage collection of the referenced object"], "IncorrectAnswers": ["A reference to small objects", "A low-priority reference", "A reference with less memory", "A deprecated reference type", "A reference to None", "A reference that auto-deletes"], "RegEx": "", "RegExDescription": ""}
{"id": "e5f6a7b8c9d0405060718293040a2b3d", "QuestionId": 122, "Difficulty": "L3", "Category": "Advanced", "Type": "multiple_choice", "Description": "__call__ makes instances callable like functions. When you do obj(), Python calls obj.__call__(). Useful for stateful functions, decorators that need state, and implementing functors.", "Question": "What does implementing __call__ on a class allow?", "Answers": ["Instances of the class can be called like functions"], "IncorrectAnswers": ["The class becomes a function", "Methods can be called without parentheses", "The class auto-executes on import", "Instances call other instances", "The class becomes static", "Methods become properties"], "RegEx": "", "RegExDescription": ""}
{"id": "f6a7b8c9d0e1506071829304050a3b4d", "QuestionId": 123, "Difficulty": "L3", "Category": "Advanced", "Type": "multiple_choice", "Description": "send() resumes a generator and passes a value that becomes the result of the yield expression. throw() raises an exception at the yield point. close() raises GeneratorExit to terminate. These enable coroutine patterns.", "Question": "What does generator.send(value) do?", "Answers": ["Resumes the generator and the value becomes the result of the current yield expression"], "IncorrectAnswers": ["Sends value to multiple generators", "Replaces the next yield value", "Exits the generator with value", "Starts the generator with value", "Sends value to caller", "Passes value to next()"], "RegEx": "", "RegExDescription": ""}
{"id": "a7b8c9d0e1f2607182930405060a4b5d", "QuestionId": 124, "Difficulty": "L3", "Category": "Async", "Type": "multiple_choice", "Description": "asyncio.gather() runs coroutines concurrently and returns results in order. asyncio.wait() provides more control, returning done/pending sets. Both enable concurrent I/O without threads.", "Question": "What is asyncio.gather() used for?", "Answers": ["Running multiple coroutines concurrently and collecting their results"], "IncorrectAnswers": ["Collecting garbage", "Gathering thread results", "Aggregating exceptions", "Grouping tasks by type", "Collecting async functions", "Gathering module imports"], "RegEx": "", "RegExDescription": ""}
{"id": "b8c9d0e1f2a3718293040506070a5b6d", "QuestionId": 125, "Difficulty": "L3", "Category": "Async", "Type": "multiple_choice", "Description": "__aenter__ and __aexit__ are async versions of context manager methods. Use 'async with' to await them. Common for async file/database/network operations that need cleanup.", "Question": "How do you create an async context manager?", "Answers": ["Implement __aenter__ and __aexit__ as async methods, use with 'async with'"], "IncorrectAnswers": ["Use @asynccontextmanager only", "Make __enter__ async", "Use 'await with' statement", "Add async to class definition", "Use 'with async'", "Inherit from AsyncContext"], "RegEx": "", "RegExDescription": ""}
{"id": "c9d0e1f2a3b4829304050607180a6b7d", "QuestionId": 126, "Difficulty": "L3", "Category": "Advanced", "Type": "multiple_choice", "Description": "Name mangling transforms __attr to _ClassName__attr to prevent accidental override in subclasses. It's not true privacy - the attribute is still accessible with the mangled name. Use single underscore for convention-based privacy.", "Question": "What happens to attribute names starting with double underscore (name mangling)?", "Answers": ["They're renamed to _ClassName__attr to avoid conflicts in subclasses"], "IncorrectAnswers": ["They become truly private", "They're encrypted", "They cause syntax errors", "They're deleted at runtime", "They become read-only", "They're only visible in __init__"], "RegEx": "", "RegExDescription": ""}
{"id": "d0e1f2a3b4c5930405060718290a7b8d", "QuestionId": 127, "Difficulty": "L3", "Category": "Performance", "Type": "multiple_choice", "Description": "CPython interns small integers (-5 to 256) and some strings to save memory. These objects are cached and reused. That's why 'a = 256; b = 256; a is b' is True but fails for 257.", "Question": "Why does 'a = 256; b = 256; a is b' return True but 'a = 257; b = 257; a is b' return False?", "Answers": ["Python interns (caches) small integers from -5 to 256 for efficiency"], "IncorrectAnswers": ["It's a bug in Python", "256 is a special number", "is operator is inconsistent", "Only even numbers are cached", "It depends on the OS", "Both should return True"], "RegEx": "", "RegExDescription": ""}
{"id": "e1f2a3b4c5d6040506071829300a8b9d", "QuestionId": 128, "Difficulty": "L3", "Category": "Performance", "Type": "multiple_choice", "Description": "__slots__ prevents __dict__ creation, reducing memory by ~40% for small objects. Trade-off: no dynamic attribute assignment, no weak references (unless __weakref__ is in slots), and more complex inheritance.", "Question": "What memory optimization does __slots__ provide?", "Answers": ["Eliminates per-instance __dict__, reducing memory for objects with fixed attributes"], "IncorrectAnswers": ["Compresses attribute values", "Uses shared memory between instances", "Moves objects to faster memory", "Enables garbage collection", "Caches method calls", "Reduces function call overhead"], "RegEx": "", "RegExDescription": ""}
{"id": "f2a3b4c5d6e7150607182930400a9b0d", "QuestionId": 129, "Difficulty": "L4", "Category": "Internals", "Type": "multiple_choice", "Description": "PyObject is the base C struct for all Python objects. It contains ob_refcnt (reference count) and ob_type (pointer to type). Understanding this helps with C extensions and debugging memory issues.", "Question": "What is PyObject in CPython internals?", "Answers": ["The base C struct containing reference count and type pointer for all Python objects"], "IncorrectAnswers": ["A special Python class", "The Python compiler", "A memory allocator", "The bytecode interpreter", "A garbage collector", "A debug utility"], "RegEx": "", "RegExDescription": ""}
{"id": "a3b4c5d6e7f8260718293040500a0b1d", "QuestionId": 130, "Difficulty": "L4", "Category": "Internals", "Type": "multiple_choice", "Description": "dis module shows bytecode instructions. LOAD_FAST loads local variable, BINARY_OP performs operations, CALL calls functions, RETURN_VALUE returns. Useful for optimization and understanding execution.", "Question": "What does the dis module do?", "Answers": ["Disassembles Python functions to show their bytecode instructions"], "IncorrectAnswers": ["Distributes code to workers", "Disables debugging", "Disconnects from servers", "Displays documentation", "Disables modules", "Dismantles objects"], "RegEx": "", "RegExDescription": ""}
{"id": "b4c5d6e7f8a9371829304050600a1b2d", "QuestionId": 131, "Difficulty": "L4", "Category": "Internals", "Type": "multiple_choice", "Description": ".pyc files contain marshalled code objects (bytecode). The header includes Python version magic number, timestamp, and source size. Python skips recompilation if .pyc is newer than .py.", "Question": "What is stored in .pyc files?", "Answers": ["Compiled bytecode with version magic number, timestamp, and serialized code objects"], "IncorrectAnswers": ["Machine code", "Encrypted source code", "Documentation strings only", "Type information", "Optimized Python code", "C extension code"], "RegEx": "", "RegExDescription": ""}
{"id": "c5d6e7f8a9b0481930405060700a2b3d", "QuestionId": 132, "Difficulty": "L4", "Category": "Typing", "Type": "multiple_choice", "Description": "Protocol (PEP 544) defines structural subtyping - classes don't need to inherit, just implement required methods. Like Go interfaces or TypeScript structural types. Use typing.Protocol as base class.", "Question": "What is a Protocol in Python's typing system?", "Answers": ["A way to define structural subtyping - any class with matching methods is compatible"], "IncorrectAnswers": ["A network protocol wrapper", "A required parent class", "A deprecated typing feature", "A runtime type checker", "A serialization format", "A naming convention"], "RegEx": "", "RegExDescription": ""}
{"id": "d6e7f8a9b0c1592040506071800a3b4d", "QuestionId": 133, "Difficulty": "L4", "Category": "Typing", "Type": "multiple_choice", "Description": "TypeVar creates a type placeholder. With bound=, it constrains to a type or its subclasses. With constraints (multiple types), it must be exactly one of them. Enables generic functions and classes.", "Question": "What is TypeVar used for in Python typing?", "Answers": ["Creating generic type parameters that can represent different types while maintaining consistency"], "IncorrectAnswers": ["Creating type aliases", "Defining variable types", "Checking types at runtime", "Converting between types", "Creating type errors", "Documenting types"], "RegEx": "", "RegExDescription": ""}
{"id": "e7f8a9b0c1d2603050607182900a4b5d", "QuestionId": 134, "Difficulty": "L4", "Category": "Typing", "Type": "multiple_choice", "Description": "@overload decorates multiple function signatures showing different parameter/return type combinations. The actual implementation follows without @overload. Only for static type checkers - no runtime effect.", "Question": "What does @typing.overload do?", "Answers": ["Declares multiple type signatures for a function for static type checkers"], "IncorrectAnswers": ["Enables function overloading like C++", "Creates multiple function versions", "Overrides parent methods", "Loads functions lazily", "Enables operator overloading", "Caches function calls"], "RegEx": "", "RegExDescription": ""}
{"id": "f8a9b0c1d2e3714060718293000a5b6d", "QuestionId": 135, "Difficulty": "L4", "Category": "Advanced", "Type": "multiple_choice", "Description": "exec() executes Python code from a string. eval() only evaluates expressions. Both accept optional globals/locals dicts. Security risk with untrusted input - prefer ast.literal_eval() for safe parsing.", "Question": "What is the difference between exec() and eval()?", "Answers": ["exec() executes statements (no return), eval() evaluates a single expression (returns result)"], "IncorrectAnswers": ["They are identical", "exec() is faster", "eval() handles multiple lines", "exec() only works in functions", "eval() is deprecated", "exec() returns values"], "RegEx": "", "RegExDescription": ""}
{"id": "a9b0c1d2e3f4825071829304000a6b7d", "QuestionId": 136, "Difficulty": "L4", "Category": "Advanced", "Type": "multiple_choice", "Description": "__prepare__ is called before the class body executes to create the namespace dict. Return a custom dict (like OrderedDict) to track definition order. Commonly used in ORMs and configuration DSLs.", "Question": "What is __prepare__ in metaclass programming?", "Answers": ["A class method that returns the namespace dict for the class body before it executes"], "IncorrectAnswers": ["Prepares the class for garbage collection", "Initializes static attributes", "Prepares method resolution order", "Sets up class inheritance", "Prepares the constructor", "Initializes class documentation"], "RegEx": "", "RegExDescription": ""}
{"id": "b0c1d2e3f4a5936182930405000a7b8d", "QuestionId": 137, "Difficulty": "L4", "Category": "Advanced", "Type": "multiple_choice", "Description": "__init_subclass__ is called when a class is subclassed. It receives the subclass as first argument and any **kwargs from the class definition. Simpler alternative to metaclasses for class customization.", "Question": "What is __init_subclass__ used for?", "Answers": ["A hook called when the class is subclassed, allowing customization of subclasses"], "IncorrectAnswers": ["Initializing subclass instances", "Preventing subclassing", "Creating abstract subclasses", "Importing subclass modules", "Validating subclass names", "Documenting subclasses"], "RegEx": "", "RegExDescription": ""}
{"id": "c1d2e3f4a5b6047293040506000a8b9d", "QuestionId": 138, "Difficulty": "L4", "Category": "Performance", "Type": "multiple_choice", "Description": "Local variable access uses LOAD_FAST (array index lookup). Global uses LOAD_GLOBAL (dict lookup). Local is faster. That's why 'x = len' then loop using 'x()' is faster than calling 'len()' repeatedly.", "Question": "Why are local variables faster than global variables in Python?", "Answers": ["Locals use array index lookup (LOAD_FAST) vs globals' dict lookup (LOAD_GLOBAL)"], "IncorrectAnswers": ["Locals are cached in CPU", "Globals use more memory", "Locals are compiled to C", "Globals require thread locks", "Locals use less bytecode", "Globals are always copied"], "RegEx": "", "RegExDescription": ""}
{"id": "d2e3f4a5b6c7158304050607000a9b0d", "QuestionId": 139, "Difficulty": "L4", "Category": "Async", "Type": "multiple_choice", "Description": "__await__ makes an object awaitable. It must return an iterator. Coroutines use this internally. You can create custom awaitables by implementing __await__ to wrap generators or other async operations.", "Question": "What does __await__ method enable?", "Answers": ["Makes an object awaitable in async code by returning an iterator"], "IncorrectAnswers": ["Pauses execution automatically", "Enables multithreading", "Creates async functions", "Handles async exceptions", "Starts the event loop", "Cancels async tasks"], "RegEx": "", "RegExDescription": ""}
{"id": "e3f4a5b6c7d8269405060718000a0b1d", "QuestionId": 140, "Difficulty": "L4", "Category": "Async", "Type": "multiple_choice", "Description": "Semaphore limits concurrent access. asyncio.Semaphore(10) allows 10 concurrent operations. Use 'async with sem:' to acquire/release. Useful for rate limiting API calls or database connections.", "Question": "What is asyncio.Semaphore used for?", "Answers": ["Limiting the number of concurrent operations in async code"], "IncorrectAnswers": ["Signaling between threads", "Measuring async performance", "Counting completed tasks", "Logging async operations", "Scheduling task priorities", "Managing memory allocation"], "RegEx": "", "RegExDescription": ""}
{"id": "f4a5b6c7d8e9370506071829000a1b2d", "QuestionId": 141, "Difficulty": "L5", "Category": "Internals", "Type": "multiple_choice", "Description": "The frame object (sys._getframe()) contains execution context: f_locals, f_globals, f_code, f_lineno, f_back (previous frame). Used by debuggers, profilers, and introspection tools.", "Question": "What information does a Python frame object contain?", "Answers": ["Local/global variables, code object, line number, and reference to the calling frame"], "IncorrectAnswers": ["Only local variables", "Only the stack trace", "Only exception info", "Only function arguments", "Only the return value", "Only bytecode"], "RegEx": "", "RegExDescription": ""}
{"id": "a5b6c7d8e9f0481607182930000a2b3d", "QuestionId": 142, "Difficulty": "L5", "Category": "Internals", "Type": "multiple_choice", "Description": "sys.settrace() sets a trace function called for each line, call, return, and exception. Used by debuggers (pdb) and coverage tools. Significantly slows execution. frame.f_trace can set per-frame traces.", "Question": "What does sys.settrace() do?", "Answers": ["Sets a function called for line execution, calls, returns, and exceptions (used by debuggers)"], "IncorrectAnswers": ["Traces memory allocation", "Logs function calls only", "Creates stack traces", "Enables debug mode", "Traces module imports", "Sets logging level"], "RegEx": "", "RegExDescription": ""}
{"id": "b6c7d8e9f0a1592718293040000a3b4d", "QuestionId": 143, "Difficulty": "L5", "Category": "Internals", "Type": "multiple_choice", "Description": "Code objects (func.__code__) contain co_code (bytecode), co_consts (constants), co_varnames (local names), co_freevars (closure variables), co_cellvars (cells for nested functions). Immutable.", "Question": "What information is stored in a Python code object?", "Answers": ["Bytecode, constants, variable names, free variables, cell variables, and metadata"], "IncorrectAnswers": ["Only source code", "Only function name", "Only line numbers", "Only documentation", "Only argument names", "Only return type"], "RegEx": "", "RegExDescription": ""}
{"id": "c7d8e9f0a1b2603829304050000a4b5d", "QuestionId": 144, "Difficulty": "L5", "Category": "Internals", "Type": "multiple_choice", "Description": "ctypes and cffi interface with C libraries. ctypes.CDLL loads shared libraries. Define argument/return types for type safety. cffi is more modern with better error messages. Both bypass the GIL in C code.", "Question": "How does ctypes allow calling C functions from Python?", "Answers": ["Loads shared libraries (.so/.dll), defines function signatures, and marshals Python types to C"], "IncorrectAnswers": ["Compiles Python to C", "Embeds C in Python source", "Uses subprocess to run C", "Converts C to Python", "Requires Cython wrapper", "Only works with Python C API"], "RegEx": "", "RegExDescription": ""}
{"id": "d8e9f0a1b2c3714930405060000a5b6d", "QuestionId": 145, "Difficulty": "L5", "Category": "Memory", "Type": "multiple_choice", "Description": "pymalloc is CPython's specialized allocator for small objects (<=512 bytes). It uses arenas, pools, and blocks to reduce fragmentation and system call overhead. Larger objects use the system allocator.", "Question": "What is pymalloc in CPython?", "Answers": ["A specialized small-object allocator using arenas and pools for efficiency"], "IncorrectAnswers": ["A memory debugger", "A garbage collector", "A memory profiler", "A cache system", "A JIT compiler", "A serialization tool"], "RegEx": "", "RegExDescription": ""}
{"id": "e9f0a1b2c3d4825040506071000a6b7d", "QuestionId": 146, "Difficulty": "L5", "Category": "Memory", "Type": "multiple_choice", "Description": "gc.get_objects() returns all tracked objects. gc.get_referrers(obj) shows what references obj. tracemalloc traces memory allocations with file/line info. objgraph visualizes reference graphs.", "Question": "How can you debug reference cycles and memory leaks in Python?", "Answers": ["Use gc module (get_objects, get_referrers), tracemalloc, and tools like objgraph"], "IncorrectAnswers": ["Only manual inspection", "Python doesn't have memory leaks", "Use print statements", "Restart the interpreter", "Only valgrind works", "Check sys.getsizeof() only"], "RegEx": "", "RegExDescription": ""}
{"id": "f0a1b2c3d4e5936150607182000a7b8d", "QuestionId": 147, "Difficulty": "L5", "Category": "Advanced", "Type": "multiple_choice", "Description": "__class_getitem__ enables subscripting classes (MyClass[int]). Returns parameterized types for generics. Used by list, dict, typing module. Added in Python 3.7 for PEP 560 generic types support.", "Question": "What does __class_getitem__ enable?", "Answers": ["Allows a class to be subscripted like List[int], returning a parameterized generic type"], "IncorrectAnswers": ["Gets items from class dict", "Creates class instances", "Accesses class attributes", "Inherits from generic base", "Defines type constraints", "Validates type arguments"], "RegEx": "", "RegExDescription": ""}
{"id": "a1b2c3d4e5f6047260718293000a8b9d", "QuestionId": 148, "Difficulty": "L5", "Category": "Advanced", "Type": "multiple_choice", "Description": "__set_name__ is called when a descriptor is assigned to a class attribute, receiving the class and attribute name. Enables descriptors to know their name without requiring it as a constructor argument.", "Question": "When is __set_name__ called on a descriptor?", "Answers": ["When the descriptor is assigned to a class attribute during class creation"], "IncorrectAnswers": ["When setting the descriptor value", "When the class is instantiated", "When the module is imported", "When the method is called", "When the class is garbage collected", "When __init__ completes"], "RegEx": "", "RegExDescription": ""}
{"id": "b2c3d4e5f6a7158371829304000a9b0d", "QuestionId": 149, "Difficulty": "L5", "Category": "Performance", "Type": "multiple_choice", "Description": "LEGB: Local (function), Enclosing (outer functions), Global (module), Built-in. Python searches in this order. 'global' and 'nonlocal' modify scope for assignment. Closures capture Enclosing scope.", "Question": "What is the LEGB rule in Python scope resolution?", "Answers": ["Local, Enclosing, Global, Built-in - the order Python searches for names"], "IncorrectAnswers": ["A memory layout rule", "A garbage collection order", "A module import order", "A syntax parsing rule", "An exception handling order", "A thread scheduling rule"], "RegEx": "", "RegExDescription": ""}
{"id": "c3d4e5f6a7b8269482930405000a0b1d", "QuestionId": 150, "Difficulty": "L5", "Category": "Performance", "Type": "multiple_choice", "Description": "String interning (sys.intern()) stores strings in a global table for reuse. Identifier-like strings are auto-interned. Use for large datasets with repeated strings to save memory and enable 'is' comparisons.", "Question": "What is string interning and when is it useful?", "Answers": ["Caching strings in a global table for memory savings and fast identity comparison"], "IncorrectAnswers": ["Encrypting strings", "Compressing strings", "Validating strings", "Formatting strings", "Parsing strings", "Converting strings to bytes"], "RegEx": "", "RegExDescription": ""}
{"id": "d4e5f6a7b8c9370593040506000a1b2d", "QuestionId": 151, "Difficulty": "L5", "Category": "Async", "Type": "multiple_choice", "Description": "contextvars provides async-safe context-local storage. Unlike threading.local, it works correctly with async tasks. ContextVar stores values that propagate through async call chains. Added in Python 3.7.", "Question": "What problem does contextvars module solve?", "Answers": ["Provides async-safe context-local storage that correctly propagates through coroutines"], "IncorrectAnswers": ["Manages function contexts", "Handles context managers", "Stores global variables", "Creates execution contexts", "Manages thread contexts", "Handles exception contexts"], "RegEx": "", "RegExDescription": ""}
{"id": "e5f6a7b8c9d0481604050607000a2b3d", "QuestionId": 152, "Difficulty": "L4", "Category": "Modules", "Type": "multiple_choice", "Description": "importlib.import_module(name) imports a module by string name. importlib.reload(module) re-imports a module. Useful for plugins, dynamic imports, and development workflows.", "Question": "How do you import a module by name string at runtime?", "Answers": ["importlib.import_module('module_name')"], "IncorrectAnswers": ["__import__('module_name') is preferred", "exec('import module_name')", "eval('import module_name')", "import('module_name')", "load_module('module_name')", "require('module_name')"], "RegEx": "", "RegExDescription": ""}
{"id": "f6a7b8c9d0e1592715060718000a3b4d", "QuestionId": 153, "Difficulty": "L4", "Category": "Modules", "Type": "multiple_choice", "Description": "__import__ is the built-in called by import statements. It's low-level and harder to use correctly. importlib.import_module() is the recommended API for dynamic imports since Python 3.1.", "Question": "What is the difference between __import__ and importlib.import_module?", "Answers": ["importlib.import_module is the recommended high-level API; __import__ is low-level and tricky"], "IncorrectAnswers": ["They are identical", "__import__ is newer", "importlib is deprecated", "__import__ is faster", "importlib doesn't work with packages", "__import__ is more Pythonic"], "RegEx": "", "RegExDescription": ""}
{"id": "a7b8c9d0e1f2603826071829000a4b5d", "QuestionId": 154, "Difficulty": "L3", "Category": "Error_Handling", "Type": "multiple_choice", "Description": "Exception chaining uses 'raise X from Y' to indicate X was caused by Y. 'from None' suppresses the context. __cause__ stores explicit cause, __context__ stores implicit (automatic) context.", "Question": "What does 'raise ExceptionA from ExceptionB' do?", "Answers": ["Creates explicit exception chain showing ExceptionB caused ExceptionA"], "IncorrectAnswers": ["Raises both exceptions", "Converts ExceptionB to ExceptionA", "Ignores ExceptionB", "Raises ExceptionB instead", "Merges exception messages", "Creates exception union"], "RegEx": "", "RegExDescription": ""}
{"id": "b8c9d0e1f2a3714937182930000a5b6d", "QuestionId": 155, "Difficulty": "L3", "Category": "Error_Handling", "Type": "multiple_choice", "Description": "ExceptionGroup (Python 3.11) holds multiple exceptions. 'except*' catches and handles subgroups. Useful for concurrent code where multiple operations can fail. Each subgroup is handled separately.", "Question": "What is ExceptionGroup in Python 3.11+?", "Answers": ["A container for multiple exceptions that can be handled with except* syntax"], "IncorrectAnswers": ["A group of exception classes", "A way to ignore exceptions", "A logging mechanism", "A deprecated feature", "A testing utility", "An exception category"], "RegEx": "", "RegExDescription": ""}
{"id": "c9d0e1f2a3b4825048293040000a6b7d", "QuestionId": 156, "Difficulty": "L3", "Category": "Testing", "Type": "multiple_choice", "Description": "pytest fixtures provide setup/teardown via @pytest.fixture. yield-based fixtures run code after yield as teardown. scope='module'/'session' controls sharing. conftest.py shares fixtures across files.", "Question": "What are pytest fixtures?", "Answers": ["Reusable setup/teardown functions that provide test dependencies via dependency injection"], "IncorrectAnswers": ["Fixed test values", "Static test data", "Test file templates", "Test class bases", "Mock objects only", "Assertion helpers"], "RegEx": "", "RegExDescription": ""}
{"id": "d0e1f2a3b4c5936159304050000a7b8d", "QuestionId": 157, "Difficulty": "L3", "Category": "Testing", "Type": "multiple_choice", "Description": "unittest.mock.patch() replaces objects during test. Use as decorator or context manager. patch.object() patches specific attributes. MagicMock auto-creates attributes and methods. spec= enforces API.", "Question": "How does unittest.mock.patch work?", "Answers": ["Temporarily replaces an object/attribute with a mock during test execution"], "IncorrectAnswers": ["Permanently modifies code", "Patches source files", "Creates test patches", "Fixes failing tests", "Updates test fixtures", "Patches network calls only"], "RegEx": "", "RegExDescription": ""}
{"id": "e1f2a3b4c5d6047164050607000a8b9d", "QuestionId": 158, "Difficulty": "L4", "Category": "Advanced", "Type": "multiple_choice", "Description": "__subclasshook__ on an ABC allows customizing isinstance/issubclass checks. Return True for virtual subclasses without registration. Used by typing.Protocol and abstract collections.", "Question": "What does __subclasshook__ do in an ABC?", "Answers": ["Customizes isinstance/issubclass checks to enable structural subtyping"], "IncorrectAnswers": ["Hooks into subclass creation", "Prevents subclassing", "Lists all subclasses", "Validates subclass methods", "Initializes subclasses", "Documents subclass requirements"], "RegEx": "", "RegExDescription": ""}
{"id": "f2a3b4c5d6e7158275060718000a9b0d", "QuestionId": 159, "Difficulty": "L4", "Category": "Advanced", "Type": "multiple_choice", "Description": "PEP 614 (Python 3.9) allows any expression as decorator, not just names/calls. Enables decorator factories returning decorators, conditional decorators, and more flexible metaprogramming.", "Question": "What did PEP 614 change about decorator syntax in Python 3.9?", "Answers": ["Allows any expression as decorator, not just names and attribute access"], "IncorrectAnswers": ["Added async decorators", "Deprecated decorators", "Required parentheses", "Changed decorator order", "Added decorator types", "Removed stacking limit"], "RegEx": "", "RegExDescription": ""}
{"id": "a3b4c5d6e7f8269386071829000a0b1d", "QuestionId": 160, "Difficulty": "L5", "Category": "Internals", "Type": "multiple_choice", "Description": "The GIL is released during I/O and can be released in C extensions (Py_BEGIN_ALLOW_THREADS). Numpy, sqlite3, and many libraries release GIL for computation. Use multiprocessing or C extensions for CPU parallelism.", "Question": "When is the GIL released in CPython?", "Answers": ["During I/O operations and in C extensions that explicitly release it"], "IncorrectAnswers": ["Never released", "During all function calls", "Only in async code", "When memory is low", "During garbage collection only", "When threads sleep"], "RegEx": "", "RegExDescription": ""}
